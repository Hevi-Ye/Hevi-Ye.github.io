---
layout: post
title:  "什么是字节序"
date:   2018-06-24 22:14:54
categories: byte
tags: Byte-Order
---

* content
{:toc}

在不同的计算机体系结构中，对于数据（比特、字节、字）等的存储和传输机制有所不同，因而引发了计算机领域中一个潜在但是又很重要的问题，即通信双方交流的信息单元应该以什么样的顺序进行传送。如果达不成一致的规则，计算机的通信与存储将会无法进行。
目前在各种体系的计算机中通常采用的字节存储机制主要有两种：大端（Big-endian）和小端（Little-endian）。






### 例子
假设用户申请了一个2个字节的内存，要存入一个数字15（该数字类型为int16，二进制表示为：00000000 00001111）

![stack_order]({{site.url}}/images/stack_order.png)

### 定义
* 大端（Big Endian）: 高位地址存放在低位的内存地址
* 小端（Little Endian）: 高位址存放在高位的内存地址

### 网络字节序
TCP/IP协议规定使用“大端”字节序为网络字节序，某些不使用大端字节序的计算器就要在发送数据之前把字节序转成大端的字节序，接收的时候再把大端的字节序转小小端的字节序

### 与数值的转换

* 将2个字节的数字511(0x01ff)转成大端字节

```go
buf := make([]byte, 2)
val := uint16(511)
// 511的二进制表示为：0000 0001 1111 1111

x := val >> 8 // => 0000 0000 0000 0001
y := val >> 0 // => 0000 0001 1111 1111

buf[0] = byte(x) // => 1
buf[1] = byte(y) // => 255
// PS: 大类型（uint16：2字节）转成小类型（byte：1字节）会丢失精度
// 结果：buf = {1, 255}
```
* 将2个字节的数字511(0x01ff)转成小端字节

```go
buf := make([]byte, 2)
val := uint16(511)
// 511的二进制表示为：0000 0001 1111 1111

x := val >> 0 // => 0000 0001 1111 1111
y := val >> 8 // => 0000 0000 0000 0001

buf[0] = byte(x) // => 255
buf[1] = byte(y) // => 1
// PS: 大类型（uint16：2字节）转成小类型（byte：1字节）会丢失精度
// 结果：buf = {255, 1}
```
* 将大端的2字节转换成int16的值

```go
buf := []byte{1, 255}

x := buf[0] << 8 // => 0000 0001 << 8 => 0000 0000 0000 0000 0000 0001 0000 0000
y := buf[1] << 0 // => 1111 1111 << 0 => 0000 0000 0000 0000 0000 0000 1111 1111
// PS: 位移后 x、y 都变成int类型

val := uint16(x | y) // => 0000 0001 1111 1111
// 结果： val = 511
```
* 将小端的2字节转换成int16的值

```go
buf := []byte{255, 1}

x := buf[0] << 0 // => 1111 1111 << 0 => 0000 0000 0000 0000 0000 0000 1111 1111
y := buf[1] << 8 // => 0000 0001 << 8 => 0000 0000 0000 0000 0000 0001 0000 0000
// PS: 位移后 x、y 都变成int类型

val := uint16(x | y) // => 0000 0001 1111 1111
// 结果： val = 511
```

### 判断机器的字节序

```go
package main

import (
	"fmt"
)

func main() {
    var x int16 = 0x00FF
    // x的二进制为：0000 0000 1111 1111
    // 如果是小端，那么在内存中应该这样存放：
    // 0000 0000 1111 1111
    // 如果是大端，那么在内存中应该这样存放：
    // 1111 1111 0000 0000

    // byte(x) 总会取数据的低地址位
    // 所以小端的byte(x)=1111 1111，大端的byte(x)=0000 0000

	if byte(x) == 0xFF {
		fmt.Println("little endian")
	} else {
		fmt.Println("big endian")
	}
}
```