---
layout: post
title:  "在栈上是如何调用函数的"
date:   2018-06-24 22:14:54
categories: stack
tags: Stack
---

* content
{:toc}

### 栈（Stack）是用来干什么的？
主要是用来运行函数的！是因为它结构的特殊性（后进先出，LIFO），跟函数的调用过程一样，如果函数是一层调用一层，那最后调用的那一层最先退出。





### 例子

新建一个test.c的文件，内容如下：
```c
int add(int a, int b)
{
	return a+b;
}

int main()
{
	return add(1,2);
}
```

当系统执行`main()`的时候，会在栈上新建一个栈帧，所有`main`里面的非静态的局部变量都会在这个栈帧里面，`main`结束后系统就会自己回收这个栈帧，释放里面的所有局部变量。当`main`调用其他函数`add()`的时候，系统又会在栈上新建一个栈帧给`add`使用。

```shell
$ gcc test.c
$ objdump -S a.out
```

将上面的代码运行在64位的Linux系统下得到汇编代码如下：
```
00000000004004ed <add>:
  4004ed:       55                      push   %rbp 			// 保存main函数的%rbp的值（这个值就是main函数栈底的地址）
  4004ee:       48 89 e5                mov    %rsp,%rbp 		// 将%rbp指向%rsp，相当于 %rbp = %rsp，现在的%rbp跟上一步的%rbp已经没有关系了，它现在指向当前函数的栈顶
  4004f1:       89 7d fc                mov    %edi,-0x4(%rbp) 	// 将在main函数里赋值的edi的值赋值给(%rbp)-0x4这个地址
  4004f4:       89 75 f8                mov    %esi,-0x8(%rbp) 	// 将在main函数里赋值的sei的值赋值给(%rbp)-0x8这个地址
  4004f7:       8b 45 f8                mov    -0x8(%rbp),%eax  // 相当于：%eax = (%rbp)-0x8
  4004fa:       8b 55 fc                mov    -0x4(%rbp),%edx 	// 相当于：%edx = (%rbp)-0x4
  4004fd:       01 d0                   add    %edx,%eax		// 相当于：%edx = %edx + %eax
  4004ff:       5d                      pop    %rbp 			// 将%rbp恢复到旧的%rbp(指向main的%rbp),再把保存的%rbp删除掉
  400500:       c3                      retq					// 返回main函数
0000000000400501 <main>:
  400501:       55                      push   %rbp
  400502:       48 89 e5                mov    %rsp,%rbp
  400505:       be 02 00 00 00          mov    $0x2,%esi		// 相当于：%esi = 2
  40050a:       bf 01 00 00 00          mov    $0x1,%edi 		// 相当于：%edi = 1
  40050f:       e8 d9 ff ff ff          callq  4004ed <add> 	// 调用函数
  400514:       5d                      pop    %rbp
  400515:       c3                      retq
  400516:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40051d:       00 00 00
```

	上面的以`%`开关的变量都是系统的寄存器
	像`(%rbp)`是指取`%rbp`这个寄存器的地址，`(%rbp)-0x4`是表示以`%rbp`的地下向下偏移4个字节的地址（栈是从上到下生长的）

那么被调用函数执行结束后是如何返回到调用函数的呢，这就要讲到下面几个寄存器和指令的作用了：

* `%rsp`寄存器
	- 它永远指向栈顶
	- 有数据压栈（push）都会使它向下生长
	- 有数据出栈（pop）都会使它向上回收
* `%rbp`寄存器
	- 它永远指向当前函数的栈底
	- 它可以利用偏移量来定位变量的位置

* 指令`push`是如何工作的
	1. 在`main`函数还没有调用`add`函数的时候，这时的%rbp的值指向的是`main`的栈底的地址（假设是 0x1000）
	2. 当进入`add`后，会执行指令`push %rbp`
		1. 让`%rsp`扩展8个字节：%rsp = %rsp - 0x8
		2. 将`0x1000`这个地址按默认的字节序存入在这个空间里，这里就知道了后面要恢复的时候要恢复到哪个地址去
	3. 执行`mov %rsp,%rbp`, 将`%rbp`指向栈顶，相当于：%rbp = %rsp，之后可能会压入其他数据（这个例子中没有），所以`%rsp`会再向下生长，`%rbp`又变成当前函数的栈底
* 指令`pop`是如何工作的
	1. 在执行`pop`之前会先执行这个指令`mov %rbp,%rsp`（这个例子没有，因为没有压入其他数据，这时：%rbp==%rsp）, 让`%rsp`重新指向`%rbp`，相当于：%rsp = %rbp
	2. 执行`pop %rbp`
		1. 将保存的`%rbp`的值（0x1000）重新赋值给`%rbp`，这时的`%rbp`是已经又指回了`main`的栈底了
		2. 弹出保存的`0x1000`这个值
		3. 将`%rsp`的值回收，相当于：%rsp = %rsp + 0x8，这时所有的数据就都恢复和调用前一样了
